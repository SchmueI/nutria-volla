const kDeps = [
  {
    name: "main",
    kind: "virtual",
    deps: [
      "shared-fluent",
      "shoelace-light-theme",
      "shoelace-setup",
      "shoelace-button",
    ],
  },
];

// Generated by `figlet Capyloon`
const banner = [
  "  ____                  _                   ",
  " / ___|__ _ _ __  _   _| | ___   ___  _ __  ",
  "| |   / _` | '_ \\| | | | |/ _ \\ / _ \\| '_ \\ ",
  "| |__| (_| | |_) | |_| | | (_) | (_) | | | |",
  " \\____\\__,_| .__/ \\__, |_|\\___/ \\___/|_| |_|",
  "           |_|    |___/                     ",
  "",
];

function addLink(url) {
  let link = document.createElement("link");
  link.setAttribute("rel", "stylesheet");
  link.setAttribute("href", url);
  document.head.appendChild(link);
  return link;
}

function loadScript(url, defer = false) {
  let script = document.createElement("script");
  script.setAttribute("src", url);
  if (defer) {
    script.setAttribute("defer", "true");
  }
  document.head.appendChild(script);
  return script;
}

class Deck {
  constructor() {
    this.current = "welcome";
  }

  switchTo(name) {
    window[this.current].classList.add("hidden");
    window[name].classList.remove("hidden");
    this.current = name;
  }
}

let deck = new Deck();

function openTerminal() {
  var term;
  const websocket = new WebSocket("ws://127.0.0.1:7703");
  websocket.binaryType = "arraybuffer";

  websocket.onopen = (evt) => {
    // Send the command to start a shell.
    let command = "/system/bin/sh";
    if (location.port == 8081) {
      // use /usr/bin/bash on Linux and /bin/zsh on Mac
      if (navigator.platform.startsWith("Linux")) {
        command = "/usr/bin/bash";
      } else if (navigator.platform.startsWith("Mac")) {
        command = "/bin/zsh";
      } else {
        console.error(`Unsupported platform: ${navigator.platform}`);
        return;
      }
    }

    console.log(`ZZZ Sending command: '${command}'`);
    websocket.send(command);

    term = new Terminal({
      cursorBlink: true,
      fontFamily: "CommitMono, Droid Sans Mono, mono, monospace",
      scrollback: 1000,
    });

    deck.switchTo("xterm");

    banner.forEach((line) => {
      term.write(`  ${line}\n\r`);
    });

    term.onData(function (data) {
      websocket.send(new TextEncoder().encode("\x00" + data));
    });

    term.onBinary((data) => {
      if (websocket.readyState !== 1) {
        return;
      }
      const buffer = new Uint8Array(data.length + 1);
      buffer[0] = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer[i + 1] = data.charCodeAt(i) & 255;
      }
      websocket.send(buffer);
    });

    term.onResize((event) => {
      websocket.send(
        new TextEncoder().encode(
          "\x01" + JSON.stringify({ cols: event.cols, rows: event.rows })
        )
      );
    });

    term.onTitleChange(function (title) {
      document.title = `webPTY | ${title}`;
    });

    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    term.loadAddon(new WebLinksAddon.WebLinksAddon());
    term.open(document.getElementById("xterm"));
    fitAddon.fit();
    term.focus();

    window.onresize = () => {
      fitAddon.fit();
    };

    websocket.onmessage = (event) => {
      let data = event.data;

      term.write(
        typeof data === "string" ? data : new Uint8Array(data.slice(1))
      );
    };

    websocket.onclose = websocket.onerror = (_event) => {
      if (term) {
        term.write("Session terminated");
        term.dispose();
        term = null;
      }
      deck.switchTo("welcome");
    };
  };
}

document.addEventListener("DOMContentLoaded", async () => {
  window.reconnect.onclick = openTerminal;

  await depGraphLoaded;
  let graph = new ParallelGraphLoader(addSharedDeps(addShoelaceDeps(kDeps)));
  await graph.waitForDeps("main");

  openTerminal();
});
